<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Selfie Uploader</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
      :root { --pad: 16px; }
      body { font-family: system-ui, sans-serif; padding: var(--pad); }
      h3 { margin: 0 0 8px; }
      #status, #status2 { font-size: 12px; opacity: .85; margin-top: 6px; min-height: 1.2em; }

      .mode-switch { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 12px; }
      .mode-btn { display: grid; place-items: center; gap: 6px; padding: 12px; border-radius: 12px; border: 2px solid #ddd; background: #fff; cursor: pointer; font-weight: 600; }
      .mode-btn.active { border-color: #4a90e2; background: #f1f7ff; }

      .block { display: none; }
      .block.active { display: block; }

      #cameraBox { margin-top: 10px; border-radius: 12px; overflow: hidden; background: #000; aspect-ratio: 3/4; position: relative; }
      #camera { width: 100%; height: 100%; object-fit: cover; display: block; }
      #captured { display: none; width: 100%; height: 100%; object-fit: cover; }
      .cam-overlay { position: absolute; inset: 0; display: none; align-items: center; justify-content: center; color: #fff; background: rgba(0,0,0,.25); font-weight: 600; }

      .cam-controls { position: absolute; left: 0; right: 0; bottom: 10px; display: grid; grid-template-columns: 64px 1fr 64px; gap: 10px; align-items: center; padding: 0 12px; pointer-events: none; }
      .cam-controls .left, .cam-controls .right, .cam-controls .center { display: flex; justify-content: center; align-items: center; pointer-events: auto; }
      .fab, .fab-secondary { border: none; border-radius: 999px; color: #fff; cursor: pointer; display: grid; place-items: center; }
      .fab { width: 64px; height: 64px; background: #4a90e2; box-shadow: 0 6px 20px rgba(0,0,0,.25); }
      .fab-secondary { width: 44px; height: 44px; background: rgba(0,0,0,.55); }
      .fab[disabled], .fab-secondary[disabled] { opacity: .5; cursor: default; }
      .fab:active, .fab-secondary:active { transform: scale(.98); }
      .control-stack { display: grid; gap: 4px; justify-items: center; color: #fff; font-size: 11px; }
      .control-stack .label { text-shadow: 0 1px 2px rgba(0,0,0,.6); }

      #preview { margin-top: 12px; max-width: 100%; border-radius: 12px; display: block; }
      #gallery { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-top: 16px; }
      #gallery img { width: 100%; aspect-ratio: 1 / 1; object-fit: cover; border-radius: 10px; cursor: pointer; }
      .tile { position: relative; }
      .tile.selected img { outline: 3px solid rgba(0,0,0,.3); }
      .del { position: absolute; top: 6px; right: 6px; border: none; border-radius: 999px; width: 28px; height: 28px; font-weight: 700; background: rgba(0,0,0,.55); color: #fff; display: grid; place-items: center; cursor: pointer; }
      .del:active { transform: scale(.96); }

      /* ▼ NEW: save-to-camera-roll button */
      .save {
        position: absolute;
        right: 6px;
        bottom: 6px;
        border: none;
        border-radius: 999px;
        width: 28px;
        height: 28px;
        font-weight: 700;
        background: rgba(0,0,0,.55);
        color: #fff;
        display: grid;
        place-items: center;
        cursor: pointer;
      }
      .save:active { transform: scale(.96); }

      .ok { color: #0a7b32; }
      .warn { color: #b06a00; }
      .err { color: #b00020; }
    </style>

    <!-- MediaPipe Pose (strict gate) -->
    <script type="module">
      import { PoseLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3";

      const MODEL_CANDIDATES = [
        "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task",
        "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/latest/pose_landmarker_lite.task"
      ];

      async function createLandmarker() {
        const fileset = await FilesetResolver.forVisionTasks(
          "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
        );
        let lastErr;
        for (const url of MODEL_CANDIDATES) {
          try {
            return await PoseLandmarker.createFromOptions(fileset, {
              baseOptions: { modelAssetPath: url },
              runningMode: "IMAGE",
              numPoses: 1
            });
          } catch (e) { lastErr = e; console.warn("Pose model failed:", url, e); }
        }
        throw lastErr ?? new Error("Pose Landmarker load failed");
      }

      window.__poseReady = (async () => {
        try {
          window.__poseLm = await createLandmarker();
          return true;
        } catch (e) {
          console.warn("Pose load failed — uploads will be blocked until available.", e);
          window.__poseLm = null;
          return false;
        }
      })();

      window.__detectPoseFromBlob = async function(blob) {
        if (!window.__poseLm) return null;
        try {
          let bitmap;
          if ('createImageBitmap' in window) {
            bitmap = await createImageBitmap(blob);
          } else {
            const img = document.createElement('img');
            const url = URL.createObjectURL(blob);
            await new Promise((res, rej) => { img.onload = res; img.onerror = rej; img.src = url; });
            bitmap = img;
            URL.revokeObjectURL(url);
          }
          const res = await window.__poseLm.detect(bitmap);
          if ('close' in bitmap) try { bitmap.close(); } catch {}
          return res;
        } catch (e) {
          console.warn("Pose detect failed", e);
          return null;
        }
      }
    </script>
  </head>

  <body>
    <a class="back" href="/">← Back</a>
    <h3>Upload your selfie</h3>

    <div class="mode-switch">
      <button id="cameraModeBtn" class="mode-btn active" type="button">Camera</button>
      <button id="galleryModeBtn" class="mode-btn" type="button">Gallery</button>
    </div>

    <!-- Camera Block -->
    <div id="cameraBlock" class="block active">
      <div id="cameraBox">
        <video id="camera" playsinline autoplay muted></video>
        <img id="captured" alt="Captured preview" />
        <div id="camOverlay" class="cam-overlay">Camera paused</div>

        <div class="cam-controls">
          <div class="left">
            <div class="control-stack">
              <button id="flipBtn" class="fab-secondary" type="button">⇆</button>
              <div class="label">Flip</div>
            </div>
          </div>
          <div class="center">
            <button id="captureBtn" class="fab" type="button">●</button>
            <button id="uploadCamBtn" class="fab" type="button" style="display:none;">↑</button>
          </div>
          <div class="right">
            <div class="control-stack">
              <button id="retakeBtn" class="fab-secondary" type="button" disabled>⟳</button>
              <div class="label">Retake</div>
            </div>
          </div>
        </div>
      </div>
      <div id="status"></div>
    </div>

    <!-- Gallery Block -->
    <div id="galleryBlock" class="block">
      <input id="file" type="file" accept="image/*" />
      <button id="uploadBtn" type="button" disabled>Upload</button>
      <div id="status2"></div>
      <img id="preview" alt="Preview will appear here" />
      <h3>Your Selfies</h3>
      <div id="gallery"></div>
    </div>

    <script>
      // ------- TG + base -------
      const BACKEND_BASE = "https://newfoundland-administered-peoples-limiting.trycloudflare.com";
      const tg = window.Telegram?.WebApp || { initData: "" };
      tg?.ready?.();

      const $ = (s) => document.querySelector(s);
      const setStatus = (msg, cls = "", which=1) => {
        const id = which === 1 ? "#status" : "#status2";
        const el = $(id); if (el) { el.className = cls; el.textContent = msg || ""; }
      };
      const haptic = (type) => tg?.HapticFeedback?.notificationOccurred?.(type);

      const STRICT_POSE_REQUIRED = true;

      function uniqueName(ext=".jpg") {
        const rand = Math.random().toString(36).slice(2, 8);
        return `camera_${Date.now()}_${rand}${ext}`;
      }

      // ------- Backend -------
      async function requestPresign(file) {
        const initData = tg.initData || "";
        const res = await fetch(`${BACKEND_BASE}/selfies/presign-upload`, {
          method: "POST", headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ initData, filename: file.name, contentType: file.type })
        });
        if (!res.ok) throw new Error("Failed to presign");
        return res.json();
      }

      async function finalize({ key, sizeBytes, contentType }) {
        const initData = tg.initData || "";
        const res = await fetch(`${BACKEND_BASE}/selfies/finalize`, {
          method: "POST", headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ initData, key, sizeBytes, contentType })
        });
        if (!res.ok) throw new Error("Failed to finalize");
        return res.json();
      }

      async function deleteSelfie(key) {
        const initData = tg.initData || "";
        const res = await fetch(`${BACKEND_BASE}/selfies/delete`, {
          method: "POST", headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ initData, key })
        });
        if (!res.ok) throw new Error("Failed to delete");
        return res.json();
      }

      async function loadGallery(limit = 24) {
        const initData = tg.initData || "";
        theRes = await fetch(`${BACKEND_BASE}/selfies/list`, {
          method: "POST", headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ initData, limit })
        });
        if (!theRes.ok) throw new Error("Failed to load gallery");
        const items = await theRes.json();
        renderGallery(items);

        const gPrev = $("#preview");
        if (gPrev && !gPrev.src && items.length) {
          gPrev.src = items[0].url;
          document.querySelector("#gallery .tile")?.classList.add("selected");
        }
      }

      // ▼ NEW: helper to trigger “Save to camera roll”
      function filenameFromKey(key) {
        if (!key) return `selfie_${Date.now()}.jpg`;
        const base = key.split('/').pop() || `selfie_${Date.now()}.jpg`;
        return base.includes('.') ? base : `${base}.jpg`;
      }
      function saveImage(url, suggestedName) {
        // Prefer Telegram openLink (lets the OS share-sheet / save UI appear)
        if (window.Telegram?.WebApp?.openLink) {
          window.Telegram.WebApp.openLink(url);
          return;
        }
        // Try download attribute (works on many browsers; iOS Safari may ignore)
        const a = document.createElement('a');
        a.href = url;
        a.download = suggestedName || 'photo.jpg';
        a.target = '_blank';
        a.rel = 'noopener';
        document.body.appendChild(a);
        a.click();
        a.remove();
      }

      function renderGallery(items) {
        const wrap = $("#gallery");
        wrap.innerHTML = "";
        items.forEach(it => {
          const cell = document.createElement("div");
          cell.className = "tile";

          const img = document.createElement("img");
          img.src = it.url; img.alt = it.key;
          img.addEventListener("click", () => {
            const gPrev = $("#preview");
            if (gPrev) gPrev.src = it.url;
            document.querySelectorAll("#gallery .tile.selected").forEach(n => n.classList.remove("selected"));
            cell.classList.add("selected");
          });

          // ▼ NEW: save button (bottom-right)
          const saveBtn = document.createElement("button");
          saveBtn.className = "save";
          saveBtn.title = "Save to camera roll";
          saveBtn.textContent = "↓";
          saveBtn.onclick = (e) => {
            e.stopPropagation();
            saveImage(it.url, filenameFromKey(it.key));
          };

          const btn = document.createElement("button");
          btn.className = "del"; btn.title = "Delete"; btn.textContent = "×";
          btn.onclick = async (e) => {
            e.stopPropagation();
            if (!confirm("Delete this photo?")) return;
            btn.disabled = true;
            try {
              await deleteSelfie(it.key);
              await loadGallery();
              haptic("success");
            } catch (err) {
              alert(err.message || "Delete failed");
              haptic("error");
              btn.disabled = false;
            }
          };

          cell.appendChild(img);
          cell.appendChild(saveBtn);
          cell.appendChild(btn);
          wrap.appendChild(cell);
        });
      }

      // ------- Compression -------
      const MAX_BYTES = 1_500_000, MAX_DIM = 2048;

      async function fileToBitmap(file) {
        if ('createImageBitmap' in window) {
          const bitmap = await createImageBitmap(file);
          return { img: bitmap, w: bitmap.width, h: bitmap.height, close: () => bitmap.close() };
        }
        const url = URL.createObjectURL(file);
        const img = new Image();
        await new Promise((res, rej) => { img.onload = res; img.onerror = rej; img.src = url; });
        URL.revokeObjectURL(url);
        return { img, w: img.naturalWidth, h: img.naturalHeight, close: () => {} };
      }
      function drawToCanvas(src, w, h) {
        const c = document.createElement('canvas'); c.width=w; c.height=h;
        c.getContext('2d').drawImage(src,0,0,w,h);
        return c;
      }
      async function canvasToJpegUnder(c, max) {
        let lo=0.5, hi=0.95, best=null;
        let blob=await new Promise(r=>c.toBlob(r,'image/jpeg',hi));
        if(blob.size<=max) return blob;
        for(let i=0;i<7;i++){
          const mid=(lo+hi)/2;
          blob=await new Promise(r=>c.toBlob(r,'image/jpeg',mid));
          if(blob.size<=max){ best=blob; hi=mid; } else lo=mid;
        }
        return best||blob;
      }
      async function compressImageToLimit(file,maxBytes=MAX_BYTES,maxDim=MAX_DIM){
        const {img,w,h,close}=await fileToBitmap(file);
        try {
          let tw=w,th=h;
          const scale=Math.max(w,h)>maxDim?maxDim/Math.max(w,h):1;
          if(scale<1){ tw=Math.round(w*scale); th=Math.round(h*scale); }
          let canvas=drawToCanvas(img,tw,th);
          let jpeg=await canvasToJpegUnder(canvas,maxBytes);
          let attempts=0;
          while(jpeg.size>maxBytes&&attempts<3&&Math.max(tw,th)>512){
            tw=Math.round(tw*0.85); th=Math.round(th*0.85);
            canvas=drawToCanvas(img,tw,th);
            jpeg=await canvasToJpegUnder(canvas,maxBytes);
            attempts++;
          }
          return new File([jpeg], uniqueName(".jpg"), { type:"image/jpeg" });
        } finally { close(); }
      }

      // ------- Pose validation (STRICT) -------
      async function validatePoseStrict(fileOrBlob, whichStatus) {
        try {
          const ready = await (window.__poseReady || Promise.resolve(false));
          if (!ready || !window.__poseLm || !window.__detectPoseFromBlob) {
            setStatus("Pose model not available. Please try again in a moment.", "err", whichStatus);
            return false;
          }
          const res = await window.__detectPoseFromBlob(fileOrBlob);
          const ok = !!(res && res.landmarks && res.landmarks.length > 0);
          if (!ok) setStatus("No person detected. Please retake or choose a clearer selfie.", "warn", whichStatus);
          return ok;
        } catch (e) {
          console.debug("Pose validation error", e);
          setStatus("Pose check failed. Please try again.", "err", whichStatus);
          return false;
        }
      }

      // ------- Upload pipeline (shared) -------
      async function uploadFileThroughPipeline(file, whichStatus=1) {
        try {
          setStatus("Requesting presign…", "", whichStatus);
          const { uploadUrl, key } = await requestPresign(file);

          setStatus("Uploading…", "", whichStatus);
          const putRes = await fetch(uploadUrl, {
            method: "PUT",
            headers: { "Content-Type": file.type, "x-amz-server-side-encryption": "AES256" },
            body: file
          });
          if (!putRes.ok) throw new Error("Upload failed");

          setStatus("Finalizing…", "", whichStatus);
          const { previewUrl, duplicate, message } = await finalize({
            key, sizeBytes: file.size, contentType: file.type
          });

          // Camera: show briefly then return to live
          if ($("#cameraBlock").classList.contains("active")) {
            const cap = $("#captured");
            if (cap) { cap.src = previewUrl; cap.style.display = "block"; }
            setTimeout(() => resetCameraUI(), 600);
          } else {
            const gPrev = $("#preview");
            if (gPrev) gPrev.src = previewUrl;
          }

          if ($("#galleryBlock").classList.contains("active")) {
            await loadGallery();
          }

          setStatus(message || "Uploaded", duplicate ? "warn" : "ok", whichStatus);
          tg.HapticFeedback?.notificationOccurred(duplicate ? "warning" : "success");
        } catch (e) {
          console.error(e);
          setStatus(e.message || "Something went wrong", "err", whichStatus);
          haptic("error");
          throw e;
        }
      }

      // ------- Gallery upload -------
      $("#uploadBtn").onclick = async () => {
        const original = $("#file").files[0];
        if (!original) { alert("Pick a file first"); return; }
        try {
          setStatus("Compressing…", "", 2);
          const compressed = await compressImageToLimit(original, MAX_BYTES, MAX_DIM);
          await uploadFileThroughPipeline(compressed, 2);
          $("#uploadBtn").disabled = true;
        } catch {}
      };

      $("#file").addEventListener("change", async () => {
        $("#uploadBtn").disabled = true;
        setStatus("", "", 2);
        const f = $("#file").files[0];
        if (!f) return;
        const ok = STRICT_POSE_REQUIRED ? await validatePoseStrict(f, 2) : true;
        if (ok) {
          setStatus("Looks good! You can upload.", "ok", 2);
          $("#uploadBtn").disabled = false;
          const url = URL.createObjectURL(f);
          $("#preview").src = url;
        }
      });

      // ------- Camera flow -------
      const video = $("#camera");
      const capturedImg = $("#captured");
      const overlay = $("#camOverlay");
      let stream = null;
      let facing = "user";
      let capturedBlob = null;

      function resetCameraUI() {
        if (capturedImg) {
          capturedImg.style.display = "none";
          capturedImg.src = "";
        }
        if (video) {
          video.style.display = "block";
          try { video.play(); } catch(_) {}
        }
        $("#captureBtn").disabled = false;
        $("#retakeBtn").disabled  = true;
        $("#uploadCamBtn").style.display = "none";
        capturedBlob = null;
        setStatus("", "", 1);
      }

      async function startCamera() {
        try {
          stopCamera();
          stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: facing }, audio: false });
          video.srcObject = stream;
          await video.play().catch(()=>{});
          overlay.style.display = "none";
          resetCameraUI();
        } catch (e) {
          console.error(e);
          overlay.textContent = "Camera unavailable";
          overlay.style.display = "flex";
          $("#captureBtn").disabled = true;
          $("#retakeBtn").disabled = true;
          $("#uploadCamBtn").style.display = "none";
        }
      }
      function stopCamera() {
        if (stream) { for (const t of stream.getTracks()) t.stop(); stream = null; }
      }
      $("#flipBtn").onclick = async () => { facing = (facing === "user" ? {exact:"environment"} : "user"); await startCamera(); };

      $("#captureBtn").onclick = async () => {
        if (!video.videoWidth) return;
        const w = video.videoWidth, h = video.videoHeight;
        const c = document.createElement("canvas"); c.width = w; c.height = h;
        c.getContext("2d").drawImage(video, 0, 0, w, h);
        capturedBlob = await new Promise(r => c.toBlob(r, "image/jpeg", 0.95));

        capturedImg.src = URL.createObjectURL(capturedBlob);
        capturedImg.style.display = "block";
        video.style.display = "none";
        $("#retakeBtn").disabled = false;
        $("#captureBtn").disabled = true;

        setStatus("Checking selfie…", "", 1);
        const ok = STRICT_POSE_REQUIRED ? await validatePoseStrict(capturedBlob, 1) : true;
        if (ok) {
          setStatus("Looks good! You can upload.", "ok", 1);
          $("#uploadCamBtn").style.display = "grid";
        } else {
          $("#uploadCamBtn").style.display = "none";
        }
      };

      $("#retakeBtn").onclick = () => {
        resetCameraUI();
      };

      $("#uploadCamBtn").onclick = async () => {
        if (!capturedBlob) return;
        try {
          setStatus("Compressing…", "", 1);
          const rawFile = new File([capturedBlob], uniqueName(".jpg"), { type: "image/jpeg" });
          const compressed = await compressImageToLimit(rawFile, MAX_BYTES, MAX_DIM);
          await uploadFileThroughPipeline(compressed, 1);
          await startCamera();
        } catch {}
      };

      // ------- Mode switching -------
      const camBtn = $("#cameraModeBtn");
      const galBtn = $("#galleryModeBtn");
      const camBlock = $("#cameraBlock");
      const galBlock = $("#galleryBlock");

      function activateCameraMode() {
        camBtn.classList.add("active");
        galBtn.classList.remove("active");
        camBlock.classList.add("active");
        galBlock.classList.remove("active");
        setStatus("", "", 2);
        startCamera();
      }
      async function activateGalleryMode() {
        galBtn.classList.add("active");
        camBtn.classList.remove("active");
        galBlock.classList.add("active");
        camBlock.classList.remove("active");
        setStatus("", "", 1);
        stopCamera();
        $("#uploadBtn").disabled = true;
        await loadGallery().catch(console.error);
      }

      camBtn.onclick = activateCameraMode;
      galBtn.onclick = activateGalleryMode;

      document.addEventListener("DOMContentLoaded", () => { activateCameraMode(); });
      window.addEventListener("pagehide", stopCamera);
      window.addEventListener("beforeunload", stopCamera);
    </script>
  </body>
</html>
