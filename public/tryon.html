<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Wardrobe · Dress Up</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <style>
    :root { --pad:16px }
    body { font-family: system-ui, sans-serif; padding: var(--pad); }
    a.back { display:inline-block; margin-bottom:8px; }
    h3 { margin: 0 0 8px; }
    #status { font-size:12px; opacity:.85; min-height:1.4em; margin-top:6px; }
    img#result { max-width:100%; border-radius:12px; margin-top:12px; display:none }
    button { margin-top:12px; width:100%; padding:12px; border-radius:10px; }
    .err { color:#b00020 }
    .ok { color:#0a7b32 }
    .warn { color:#b06a00 }
    .muted { opacity:.7 }
  </style>
</head>
<body>
  <a class="back" href="/">← Back</a>
  <h3>Dress up</h3>

  <button id="startBtn">Start Try-On</button>
  <div id="status" class="muted"></div>
  <img id="result" alt="Result" />

  <script>
    // --- Config / Telegram ---
    const BACKEND_BASE = "<YOUR_BACKEND_BASE>"; // e.g. https://your-tunnel.trycloudflare.com
    const tg = window.Telegram?.WebApp || { initData: "" };
    tg?.ready?.();

    // --- Helpers ---
    const $ = s => document.querySelector(s);
    const haptic = t => tg?.HapticFeedback?.notificationOccurred?.(t);
    function setStatus(msg, cls="") {
      const el = $("#status");
      el.className = cls || "muted";
      el.textContent = msg || "";
    }

    // --- API calls ---
    async function startTryOn() {
      const initData = tg.initData || "";
      const res = await fetch(`${BACKEND_BASE}/tryon/start`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ initData })
      });
      if (res.status === 409) {
        // Optional: backend can 409 if no selfie/garments; surface message
        const { message } = await res.json().catch(()=>({message:"Conflict"}));
        throw new Error(message || "Cannot start: missing selfie or garments");
      }
      if (!res.ok) throw new Error("Failed to start try-on");
      return res.json(); // { jobId }
    }

    async function checkTryOn(jobId) {
      const res = await fetch(`${BACKEND_BASE}/tryon/status?jobId=` + encodeURIComponent(jobId));
      if (!res.ok) throw new Error("Failed to check status");
      return res.json(); // { status: "queued|running|succeeded|failed", imageUrl?, message? }
    }

    // --- Polling with gentle UX ---
    let pollingAbort = null;

    async function poll(jobId) {
      setStatus("Working… this can take up to a minute.");
      const maxAttempts = 40; // ~80s at 2s interval
      let attempt = 0;
      const localAbort = new AbortController();
      pollingAbort = localAbort;

      while (attempt++ < maxAttempts && !localAbort.signal.aborted) {
        try {
          const s = await checkTryOn(jobId);
          if (s.status === "succeeded" && s.imageUrl) {
            $("#result").src = s.imageUrl;
            $("#result").style.display = "block";
            setStatus("Done ✔", "ok");
            haptic("success");
            pollingAbort = null;
            return;
          }
          if (s.status === "failed") {
            setStatus(s.message || "Try-on failed", "err");
            haptic("error");
            pollingAbort = null;
            return;
          }
          // queued / running
          const dots = ".".repeat((attempt % 3) + 1);
          setStatus((s.status === "queued" ? "Queued" : "Working") + dots);
        } catch (e) {
          // transient network hiccup — keep trying a few times
          if (attempt % 5 === 0) {
            setStatus("Still working…", "warn");
          }
        }
        await new Promise(r => setTimeout(r, 2000));
      }
      if (!localAbort.signal.aborted) {
        setStatus("Timed out. Please try again.", "err");
        haptic("error");
      }
      pollingAbort = null;
    }

    // --- Button handler ---
    const startBtn = $("#startBtn");
    startBtn.onclick = async () => {
      if (pollingAbort) {
        // Optional: allow cancel if already running
        pollingAbort.abort();
        pollingAbort = null;
        setStatus("Cancelled.", "warn");
        startBtn.disabled = false;
        startBtn.textContent = "Start Try-On";
        return;
      }

      try {
        $("#result").style.display = "none";
        $("#result").src = "";
        setStatus("Starting…");
        startBtn.disabled = true;
        startBtn.textContent = "Working…";

        const { jobId } = await startTryOn();
        await poll(jobId);
      } catch (e) {
        console.error(e);
        setStatus(e.message || "Something went wrong", "err");
        haptic("error");
      } finally {
        // restore button if not actively polling or after poll finishes/fails
        if (!pollingAbort) {
          startBtn.disabled = false;
          startBtn.textContent = "Start Try-On";
        } else {
          // If still polling, switch to Cancel affordance
          startBtn.disabled = false;
          startBtn.textContent = "Cancel";
        }
      }
    };

    // Clean up polling if user navigates away
    window.addEventListener("beforeunload", () => {
      if (pollingAbort) pollingAbort.abort();
    });
  </script>
</body>
</html>
